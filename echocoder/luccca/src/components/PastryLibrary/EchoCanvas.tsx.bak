import React, { useEffect, useMemo, useRef, useState } from "react";
import { Download, Upload, Undo2, Redo2, Trash2, ZoomIn, ZoomOut, Hand, Move, Type, PaintBucket, Droplet, Eraser, Brush, Pencil, Layers, Eye, EyeOff, Lock, LockOpen, Square, Circle, Crop, RectangleHorizontal, MousePointerSquare, Lasso, Wand2, BezierCurve, Image, Copy, Paste, Plus, Minus, Settings2, Grid3X3, Printer, Ruler, Send, Sun, Moon, ChevronDown, ChevronUp, Paintbrush2, Shapes, Scan, Pipette, Stamp, Blend, Contrast, Focus, Waypoints, Highlighter, Blend as BlendIcon } from "lucide-react";

/**
 * CustomCakeDesignStudio – Photoshop‑style image generator & editor (React/Tailwind)
 *
 * ✅ Default transparent background (checkerboard preview only)
 * ✅ Prompt → Image panel (bring your own /api/generate-image endpoint)
 * ✅ Layers with reordering, visibility, locking, opacity, blend modes
 * ✅ Tools: Move, Brush, Pencil, Eraser, Paint Bucket, Gradient, Eyedropper, Text,
 *           Shapes (Rect/Ellipse), Marquee (Rect/Ellipse), Lasso (polygonal),
 *           Magic Wand (tolerance flood select), Crop, Hand, Zoom, Clone Stamp,
 *           Dodge/Burn/Sponge, Blur/Sharpen/Smudge (basic), Pen (paths → stroke/fill)
 * ✅ Undo/Redo (per‑action snapshots, max 30 by default)
 * ✅ Canvas presets + custom size + DPI + print preview
 * ✅ Import as layer, Export PNG (preserves transparency)
 * ✅ Quick (pop) toolbar with common tool settings
 *
 * Notes
 * - This component is self‑contained for easy drop‑in. No external state libs.
 * - For AI generation, implement the /api/generate-image POST endpoint to return a PNG (base64 or blob). See generateFromPrompt().
 * - Blend modes map to CanvasRenderingContext2D.globalCompositeOperation for preview; export preserves the results (we composite on export).
 */

// ---- Types ----
type ToolId =
  | "move" | "brush" | "pencil" | "eraser" | "bucket" | "gradient" | "eyedropper"
  | "text" | "shape-rect" | "shape-ellipse" | "marquee-rect" | "marquee-ellipse"
  | "lasso" | "magicwand" | "crop" | "hand" | "zoom" | "clonestamp"
  | "dodge" | "burn" | "sponge" | "blur" | "sharpen" | "smudge" | "pen";

type BlendMode = GlobalCompositeOperation;

interface Layer {
  id: string;
  name: string;
  visible: boolean;
  locked: boolean;
  opacity: number; // 0..1
  blend: BlendMode; // e.g., 'source-over', 'multiply', ...
  canvas: HTMLCanvasElement;
  x: number; // for move tool (layer translate)
  y: number;
}

interface HistoryState {
  // Minimal snapshot: per-layer ImageData + meta
  layers: { id: string; image: ImageData; x: number; y: number; visible: boolean; opacity: number; blend: BlendMode; }[];
  activeLayerId: string;
  selectionPath: Point[] | null;
  selectionMask: ImageData | null;
}

interface Point { x: number; y: number }

// ---- Helpers ----
const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));
const uid = () => Math.random().toString(36).slice(2, 10);

const CHECKER_SIZE = 16;

const PRESET_SIZES = [
  { name: "Square 1024", w: 1024, h: 1024 },
  { name: "Poster A3 (300dpi)", w: Math.round(11.7*300), h: Math.round(16.5*300) },
  { name: "Letter (300dpi)", w: 2550, h: 3300 },
  { name: "Social (1080×1350)", w: 1080, h: 1350 },
  { name: "Banner 1920×1080", w: 1920, h: 1080 },
];

const BLEND_OPTIONS: { label: string; value: BlendMode }[] = [
  { label: "Normal", value: "source-over" },
  { label: "Multiply", value: "multiply" },
  { label: "Screen", value: "screen" },
  { label: "Overlay", value: "overlay" },
  { label: "Darken", value: "darken" },
  { label: "Lighten", value: "lighten" },
  { label: "Color Dodge", value: "color-dodge" },
  { label: "Color Burn", value: "color-burn" },
  { label: "Hard Light", value: "hard-light" },
  { label: "Soft Light", value: "soft-light" },
  { label: "Difference", value: "difference" },
  { label: "Exclusion", value: "exclusion" },
  { label: "Hue", value: "hue" },
  { label: "Saturation", value: "saturation" },
  { label: "Color", value: "color" },
  { label: "Luminosity", value: "luminosity" },
];

// ---- Main Component ----
export default function CustomCakeDesignStudio() {
  // Canvas/viewport
  const [canvasW, setCanvasW] = useState(1024);
  const [canvasH, setCanvasH] = useState(1024);
  const [dpi, setDpi] = useState(300);

  // Tooling
  const [tool, setTool] = useState<ToolId>("brush");
  const [primary, setPrimary] = useState("#000000");
  const [secondary, setSecondary] = useState("#ffffff");
  const [brushSize, setBrushSize] = useState(24);
  const [hardness, setHardness] = useState(0.7); // 0..1
  const [flow, setFlow] = useState(1);
  const [opacity, setOpacity] = useState(1);
  const [zoom, setZoom] = useState(1);
  const [isPanning, setIsPanning] = useState(false);

  // Layers
  const [layers, setLayers] = useState<Layer[]>([]);
  const [activeLayerId, setActiveLayerId] = useState<string>("");

  // Selection
  const [selectionPath, setSelectionPath] = useState<Point[] | null>(null); // polygonal path
  const selectionMaskRef = useRef<HTMLCanvasElement | null>(null); // mask canvas

  // History
  const [history, setHistory] = useState<HistoryState[]>([]);
  const [redoStack, setRedoStack] = useState<HistoryState[]>([]);
  const HISTORY_LIMIT = 30;

  // Refs
  const hostRef = useRef<HTMLDivElement | null>(null);
  const displayRef = useRef<HTMLCanvasElement | null>(null); // composited preview
  const gridRef = useRef<HTMLCanvasElement | null>(null); // checkerboard grid
  const isDrawingRef = useRef(false);
  const lastPtRef = useRef<Point | null>(null);
  const cloneSampleRef = useRef<Point | null>(null);

  // Derived
  const activeLayer = useMemo(() => layers.find(l => l.id === activeLayerId) || null, [layers, activeLayerId]);

  // Init: base layer
  useEffect(() => {
    if (layers.length === 0) {
      const base = createLayer("Layer 1", canvasW, canvasH);
      setLayers([base]);
      setActiveLayerId(base.id);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Resize all layers when canvas size changes (non‑destructive: place old into new canvas centered)
  useEffect(() => {
    if (layers.length === 0) return;
    setLayers(prev => prev.map(l => resizeLayerCanvas(l, canvasW, canvasH)));
    drawChecker();
    composite();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [canvasW, canvasH]);

  useEffect(() => { drawChecker(); composite(); }, [layers, zoom]);

  // ---- Layer utilities ----
  function createLayer(name: string, w: number, h: number): Layer {
    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    const id = uid();
    return { id, name, visible: true, locked: false, opacity: 1, blend: "source-over", canvas, x: 0, y: 0 };
  }

  function resizeLayerCanvas(layer: Layer, w: number, h: number): Layer {
    const newCanvas = document.createElement("canvas");
    newCanvas.width = w; newCanvas.height = h;
    const ctx = newCanvas.getContext("2d")!;
    ctx.globalCompositeOperation = "source-over";
    ctx.drawImage(layer.canvas, layer.x, layer.y);
    return { ...layer, canvas: newCanvas, x: 0, y: 0 };
  }

  function addLayer(name = `Layer ${layers.length + 1}`) {
    const L = createLayer(name, canvasW, canvasH);
    setLayers(prev => [L, ...prev]);
    setActiveLayerId(L.id);
    pushHistory();
  }

  function removeLayer(id: string) {
    if (layers.length === 1) return;
    setLayers(prev => prev.filter(l => l.id !== id));
    if (activeLayerId === id && layers[1]) setActiveLayerId(layers[1].id);
    pushHistory();
  }

  function duplicateActiveLayer() {
    if (!activeLayer) return;
    const copy = createLayer(`${activeLayer.name} copy`, canvasW, canvasH);
    const ctx = copy.canvas.getContext("2d")!;
    ctx.drawImage(activeLayer.canvas, 0, 0);
    copy.opacity = activeLayer.opacity; copy.blend = activeLayer.blend;
    setLayers(prev => [copy, ...prev]);
    setActiveLayerId(copy.id);
    pushHistory();
  }

  function reorderLayer(fromIndex: number, toIndex: number) {
    setLayers(prev => {
      const arr = [...prev];
      const [moved] = arr.splice(fromIndex, 1);
      arr.splice(toIndex, 0, moved);
      return arr;
    });
    pushHistory();
  }

  // ---- Checkerboard & Composite ----
  function drawChecker() {
    const grid = gridRef.current; if (!grid) return;
    grid.width = Math.round(canvasW * zoom);
    grid.height = Math.round(canvasH * zoom);
    const g = grid.getContext("2d")!;
    g.clearRect(0, 0, grid.width, grid.height);
    const s = CHECKER_SIZE * zoom;
    for (let y = 0; y < grid.height; y += s) {
      for (let x = 0; x < grid.width; x += s) {
        g.fillStyle = ((x / s + y / s) % 2 === 0) ? "#e6e6e6" : "#cfcfcf";
        g.fillRect(x, y, s, s);
      }
    }
  }

  function composite() {
    const view = displayRef.current; if (!view) return;
    view.width = Math.round(canvasW * zoom);
    view.height = Math.round(canvasH * zoom);
    const v = view.getContext("2d")!;
    v.setTransform(1, 0, 0, 1, 0, 0);
    v.clearRect(0, 0, view.width, view.height);

    // Draw layers (top of array is top of stack)
    for (let i = layers.length - 1; i >= 0; i--) {
      const L = layers[i];
      if (!L.visible) continue;
      v.globalAlpha = L.opacity;
      v.globalCompositeOperation = L.blend || "source-over";
      v.drawImage(L.canvas, Math.round(L.x * zoom), Math.round(L.y * zoom), Math.round(canvasW * zoom), Math.round(canvasH * zoom));
    }

    // Selection outline (marching ants)
    if (selectionPath && selectionPath.length > 1) {
      v.save();
      v.scale(zoom, zoom);
      v.strokeStyle = "#000"; v.lineWidth = 1; v.setLineDash([6, 6]); v.lineDashOffset = (Date.now() / 90) % 12; v.beginPath();
      v.moveTo(selectionPath[0].x, selectionPath[0].y);
      for (let i = 1; i < selectionPath.length; i++) v.lineTo(selectionPath[i].x, selectionPath[i].y);
      v.closePath(); v.stroke();
      v.strokeStyle = "#fff"; v.setLineDash([6, 6]); v.lineDashOffset = ((Date.now() / 90) % 12) + 6; v.stroke();
      v.restore();
    }
  }

// Animate marching ants
useEffect(() => {
  const id = setInterval(() => composite(), 90);
  return () => clearInterval(id);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [selectionPath, zoom, layers]);


return () => clearInterval(id);
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [selectionPath, zoom, layers]);
    </div>
  </div>
);
