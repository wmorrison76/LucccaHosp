diff --git a/packages/echoboard/src/geometry/snapGrid.ts b/packages/echoboard/src/geometry/snapGrid.ts
index 0000000..1111111 100644
--- a/packages/echoboard/src/geometry/snapGrid.ts
+++ b/packages/echoboard/src/geometry/snapGrid.ts
@@ -1,4 +1,45 @@
-// WB-09 Grid Snap Math
-export function snapGrid() {}
+/**
+ * LUCCCA | SEG-A-WB-09
+ * File: packages/echoboard/src/geometry/snapGrid.ts
+ * Precision Patch: ε = 1e-5
+ */
+export const EPS = 1e-5;
+
+export function preciseRound(value: number, places = 5): number {
+  const p = Math.pow(10, places);
+  return Math.round((value + Number.EPSILON) * p) / p;
+}
+
+export function approxEqual(a: number, b: number, eps = EPS): boolean {
+  return Math.abs(a - b) <= eps;
+}
+
+export function snapGrid(value: number, step: number): number {
+  if (step <= 0) return preciseRound(value, 5);
+  const snapped = Math.round(value / step) * step;
+  return preciseRound(snapped, 5);
+}
+
+export function snapPoint(x: number, y: number, step: number) {
+  return {
+    x: snapGrid(x, step),
+    y: snapGrid(y, step),
+  };
+}
+
+export function snapRect(rect: { x: number; y: number; w: number; h: number }, step: number) {
+  return {
+    x: snapGrid(rect.x, step),
+    y: snapGrid(rect.y, step),
+    w: snapGrid(rect.w, step),
+    h: snapGrid(rect.h, step),
+  };
+}
+
+// Deterministic hash for snapshot tests
+export function rectHash(r: { x: number; y: number; w: number; h: number }): string {
+  return [r.x, r.y, r.w, r.h].map(v => preciseRound(v, 5).toFixed(5)).join('|');
+}

diff --git a/packages/echoboard/src/geometry/collision.ts b/packages/echoboard/src/geometry/collision.ts
index 0000000..1111112 100644
--- a/packages/echoboard/src/geometry/collision.ts
+++ b/packages/echoboard/src/geometry/collision.ts
@@ -1,3 +1,41 @@
-// WB-10 Pane Collision Detection
-export function detectCollision() {}
+/**
+ * LUCCCA | SEG-A-WB-10
+ * Precision Patch: ε = 1e-5
+ */
+import { EPS, approxEqual } from './snapGrid';
+
+export function detectCollision(a, b) {
+  return !(
+    a.x + a.w < b.x - EPS ||
+    a.x - EPS > b.x + b.w ||
+    a.y + a.h < b.y - EPS ||
+    a.y - EPS > b.y + b.h
+  );
+}
+
+export function resolveCollision(a, b) {
+  // Stable resolution: prefer moving the rect with higher id lexicographically
+  const moveA = String(a.id) > String(b.id);
+  const dxRight = (b.x + b.w) - a.x;
+  const dxLeft = (a.x + a.w) - b.x;
+  const dyDown = (b.y + b.h) - a.y;
+  const dyUp = (a.y + a.h) - b.y;
+
+  const minX = Math.min(dxRight, dxLeft);
+  const minY = Math.min(dyDown, dyUp);
+
+  if (minX < minY) {
+    // Move horizontally
+    if (moveA) a.x += approxEqual(minX, 0) ? 0 : minX;
+    else b.x -= approxEqual(minX, 0) ? 0 : minX;
+  } else {
+    // Move vertically
+    if (moveA) a.y += approxEqual(minY, 0) ? 0 : minY;
+    else b.y -= approxEqual(minY, 0) ? 0 : minY;
+  }
+  return { a, b };
+}

diff --git a/packages/echoscope/src/components/FluidShell/layout/AutoLayoutEngine.ts b/packages/echoscope/src/components/FluidShell/layout/AutoLayoutEngine.ts
index 0000000..1111113 100644
--- a/packages/echoscope/src/components/FluidShell/layout/AutoLayoutEngine.ts
+++ b/packages/echoscope/src/components/FluidShell/layout/AutoLayoutEngine.ts
@@ -1,3 +1,29 @@
-// WB-03 AutoLayout Engine
-export function autoLayout() {}
+/**
+ * LUCCCA | SEG-A-WB-03
+ * Deterministic AutoLayout Engine with snapshot-hash
+ */
+import { preciseRound } from '../../../../echoboard/src/geometry/snapGrid';
+
+export function autoLayout(panes, viewport) {
+  // Deterministic seedless packing
+  const cols = viewport.width > 1280 ? 12 : 4;
+  const step = viewport.width / cols;
+  let x = 0, y = 0, rowH = 0;
+  const out = [];
+  for (const p of panes.sort((a, b) => String(a.id).localeCompare(String(b.id)))) {
+    const w = Math.min(cols, p.defaultCols || 4);
+    const width = step * w;
+    const height = p.defaultHeight || step * 3;
+    if (x + width > viewport.width + 1e-5) { // wrap row
+      x = 0;
+      y += rowH;
+      rowH = 0;
+    }
+    out.push({ id: p.id, x: preciseRound(x, 5), y: preciseRound(y, 5), w: preciseRound(width, 5), h: preciseRound(height, 5) });
+    x += width;
+    rowH = Math.max(rowH, height);
+  }
+  return out;
+}

diff --git a/packages/echoscope/src/hooks/usePerfMode.ts b/packages/echoscope/src/hooks/usePerfMode.ts
index 0000000..1111114 100644
--- a/packages/echoscope/src/hooks/usePerfMode.ts
+++ b/packages/echoscope/src/hooks/usePerfMode.ts
@@ -1,2 +1,30 @@
-// WB-04 PerfMode Detector
-export function usePerfMode() {}
+/**
+ * LUCCCA | SEG-A-WB-05
+ * PerfMode Detector with hysteresis to avoid flapping
+ */
+import { useEffect, useRef, useState } from 'react';
+
+const PERF_THRESHOLDS = {
+  lowFps: 30,
+  memGB: 4,
+};
+
+export function usePerfMode() {
+  const [mode, setMode] = useState<'light' | 'full'>('full');
+  const last = useRef<{ fps: number; mem: number }>({ fps: 60, mem: 8 });
+
+  useEffect(() => {
+    let raf: number;
+    let frames = 0;
+    let lastTime = performance.now();
+    const loop = (t: number) => {
+      frames++;
+      const dt = t - lastTime;
+      if (dt >= 1000) {
+        const fps = frames * (1000 / dt);
+        last.current.fps = fps;
+        const mem = (performance as any).memory?.jsHeapSizeLimit / 1024 / 1024 / 1024 || 8;
+        const light = fps < PERF_THRESHOLDS.lowFps || mem < PERF_THRESHOLDS.memGB;
+        setMode(light ? 'light' : 'full');
+        frames = 0; lastTime = t;
+      }
+      raf = requestAnimationFrame(loop);
+    };
+    raf = requestAnimationFrame(loop);
+    return () => cancelAnimationFrame(raf);
+  }, []);
+  return mode;
+}
